# Go语言数组与切片详解

------

###数组

1. 数组的声明

   - 数组变量名：数组声明及使用时的变量名
   - 元素数量：数组的元素数量，可以是一个表达式，但最终通过编译期计算的结果必须是整型数值，元素数量不能含有到运行时才能确认大小的数值
   - Type：可以是任意基本类型，包括数组本身，类型为数组本身时，可以实现多维数组。

   数组的每个元素都可以通过下标访问

   ```golang
   var a [3]int             // 定义三个整数的数组
   fmt.Println(a[0])        // 打印第一个元素
   fmt.Println(a[len(a)-1]) // 打印最后一个元素
   // 打印索引和元素
   for i, v := range a {
       fmt.Printf("%d %d\n", i, v)
   }
   // 仅打印元素
   for _, v := range a {
       fmt.Printf("%d\n", v)
   }
   ```

   - 默认情况下，数组的每个元素都会被初始化为元素类型对应的零值，对于数字类型来说就是 0，同时也可以使用`数组字面值语法`，用一组值来初始化数组

   ```golang
   var a [2]int = []int{1,2}
   var b [10]int = []int{1,2} //[1,2,0,0,0,0,0,0,0,0]
   ```

   - 数组定义中,如果在数组长度的位置出现`...`省略号，则表示数组的长度是根据初始化值的个数来计算

   ```golang
    a:= [...]int{1,2}
   ```

   - 数组的长度是数组类型的一个组成部分，因此 [3]int 和 [4]int 是两种不同的数组类型，数组的长度必须是常量表达式，因为数组的长度需要在编译阶段确定。

   ```
   a:=[3]int{1,2,3}
   a=[4]int{1,2,3}//编译错误
   ```

2. 比较两个数组是否相等

   - 如果两个数组类型相同（包括数组的长度，数组中元素的类型）的情况下，我们可以直接通过较运算符（`==`和 `!=`）来判断两个数组是否相等，`只有当两个数组的所有元素都是相等的时候数组才是相等的`，不能比较两个类型不同的数组，否则程序将无法完成编译。

   ```
   a:=[2]int{1,2}
   b:=[...]int{1,2}
   c:=[3]int{1,2}
   a==b a==c b==c //true false false
   ```

   

3. 遍历数组——访问每一个数组元素

4. Go语言中允许使用多维数组，因为数组属于值类型，所以多维数组的所有维度都会在创建时自动初始化零值，多维数组尤其适合管理具有父子关系或者与坐标系相关联的数据。

   ```
   值类型：所有像int、float、bool和string这些类型都属于值类型，使用这些类型的变量直接指向存在内存中的值，值类型的变量的值存储在栈中。当使用等号=将一个变量的值赋给另一个变量时，如 j = i ,实际上是在内存中将 i 的值进行了拷贝。可以通过 &i 获取变量 i 的内存地址
   
   引用类型：复杂的数据通常会需要使用多个字，这些数据一般使用引用类型保存。一个引用类型的变量r1存储的是r1的值所在的内存地址（数字），或内存地址中第一个字所在的位置，这个内存地址被称之为指针，这个指针实际上也被存在另外的某一个字中
   ```

   

5. 声明二维数组

   ```golang
   var a [2][4]arr
   //使用数组字面量来声明并且初始化二维数组
   arr :=[2][4]int{{1,2,3,4},{5,6,7,8}}
   //声明并初始化数组中索引为 1 和 3 的元素
   arr:=[2][4]int{1:{1,2,3,4}}
   ```

   - 为二维数组赋值

     ```golang
     var arr  [2][2]int
     var array [2][2]int
     arr[0][1] = 1
     arr[1][0] = 1
     //只要类型一致，就能相互赋值
     array = arr
     ```

   - 使用索引为多维数组赋值

     ```
     var arr  [2][2]int = {{1,2},{3,4}}
     var value [2]int = arr[0]
     var variable int arr[0][0]
     ```

6. 数组作为函数参数

   - Func test(arr [3]int){} 
   - Go语⾔中数组是值语义。⼀个数组变量即表示整个数组，它并不是隐式的指向第⼀个元素的指针(⽐如C语⾔的数组),⽽是⼀个完整的值。当⼀个数组变量被赋值或者被传递的时候，实际上会复制整个数组。如果数组较⼤的话，数组的赋值也会有较⼤的开销。为了避免复制数组带来的开销,可以传递⼀个指向数组的指针，但是数组指针并不是数组。

7. 总结

   ```
   //数组的初始化方式
   a:=[3]int{1,2,3}
   a:=[]int{1}
   a:=[...]{1,2,3}
   a := []int{1: 5, 6: 8}
   a := []int{1, 2, 8: 10}
   ```

   

###切片

1. 什么是切片

   - 切片（slice）是对数组的一个连续片段的引用，所以切片是一个引用类型，这个片段可以是整个数组，也可以是由起始和终止索引标识的一些项的子集。
   - 切片的内部结构包含`地址`、`大小`和`容量`，切片一般用于快速地操作一块数据集合

2. 从数组或切片生成新的切片(包头不包尾)

   - Slice(start:end)
     - Slice:表示目标切片对象
     - start:对应目标切片对象的索引
     - End:对应目标切片的结束索引
   - Make()构造

   ```golang
   a := make([]int, 2)
   b := make([]int, 2, 10) //int类型的长度为2,最大容量为10的切片b
   ```

   - 使用 `make()` 函数生成的切片一定发生了内存分配操作，但给定开始与结束位置（包括切片复位）的切片只是将新的切片结构指向已经分配好的内存区域，设定开始与结束位置，不会发生内存分配操作。

3. 切片的操作

   - 修改切片数据

   - append

     ```
     使用 append() 函数为切片动态添加元素时`如果空间不足以容纳足够多的元素，切片就会进行“扩容”，此时新切片的长度会发生改变。切片在扩容时，容量cap的扩展规律是按容量的2倍数进行扩充
     ```

   - copy

     ```
     将一个数组切片复制到另一个数组切片中，如果加入的两个数组切片不一样大，就会按照其中较小的那个数组切片的元素个数进行复制
     ```

   - cap

   - 切片的扩容

   - 删除切片元素

   - 多维切片