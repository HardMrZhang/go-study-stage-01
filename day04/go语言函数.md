# go语言函数

------

##### 函数的定义和声明

###### 什么是函数

1. 函数是执行特定任务的代码块。
2. 函数是组织好的、可重复使用的、用来实现单一或相关联功能的代码段，其可以提高应用的模块性和代码的重复利用率。
3. go中函数属于一等公民
   - 函数本身可以作为值传递
   - 支持匿名函数和闭包
   - 函数可以满足接口

###### 函数的声明

1. 函数构成了代码执行的逻辑结构，在Go语言中，函数的基本组成为：关键字 func、函数名、参数列表、返回值、函数体和返回语句，每一个程序都包含很多的函数，函数是基本的代码块。

2. go是编译型函数,所以函数的编写顺序是无关紧要的,但是尽量把main()函数写在函数的最前面,其他的函数按照一定的顺序进行编写（例如函数被调用的顺序）

3. 为什么要有函数这个东西:

   - 编写多个函数主要是为了将复杂问题分解成一系列的小问题来解决
   - 同一个任务函数可以多次被调用,有助于代码重用,降低代码的冗余性

4. 函数执行到代码块最后一行`}`之前或者 return 语句的时候会退出，其中 return 语句可以带有零个或多个参数，这些参数将作为返回值供调用者使用，简单的 return 语句也可以用来结束 for 的死循环，或者结束一个协程（goroutine）。

5. 普通函数的声明

   1. 函数声明包含函数名,形参，返回值(可以不用),函数体

      ```go
      形式参数列表描述了函数的参数名以及参数类型，这些参数作为局部变量，其值由参数调用者提供，返回值列表描述了函数返回值的变量名以及类型，如果函数返回一个无名变量或者没有返回值，返回值列表的括号是可以省略的。
      
      func 函数体(形参列表)(返回值列表){
      	函数体
      }
      //如果参数有返回值,该函数必须以return语句结尾
      //除非函数明显无法运行到结尾处，例如函数在结尾时调用了 panic 异常或函数中存在无限循环。
      func hypot(x, y float64) float64 {
          return math.Sqrt(x*x + y*y)
      }
      fmt.Println(hypot(3,4)) // "5"
      ```

   2. 在函数中，实参通过值传递的方式进行传递，因此函数的形参是实参的拷贝，对形参进行修改不会影响实参，但是，如果实参包括引用类型，如指针、slice(切片)、map、function、channel 等类型，实参可能会由于函数的间接引用被修改。

###### 函数的返回值

1. 支持多返回值,对返回值能方便的获得函数执行吼的多个返回参数。
2. 同一种类型的返回值
   - 如果返回值是同一种类型,则用括号将返回值包起来,用逗号分隔开
3. 带有变量名的返回值
   - 对返回值进行命名，这样返回值就和参数一样拥有参数变量名和类型
   - 返回值变量的默认值为类型的默认值，即数值为 0，字符串为空字符串，布尔为 false、指针为 nil 等。



##### go语言函数变量

###### Go语言中，函数也是一种类型，可以和其他类型一样保存在变量中

```go
func a(){fmt.println("a")}

func main(){
	var f func //将变量f声明为func()类型，此时f就被俗称为“回调函数”，此时f的值为 nil。
	f = a()
	f()
}


```

##### go语言匿名函数-没有名字的函数

Go语言支持匿名函数，即在需要使用函数时再定义函数，匿名函数没有函数名只有函数体，函数可以作为一种类型被赋值给函数类型的变量，匿名函数也往往以变量方式传递,Go语言支持随时在代码里定义匿名函数。

匿名函数是指不需要定义函数名的一种函数实现方式，由一个不带函数名的函数声明和函数体组成

###### 定义一个匿名函数

```go
func(参数列表)(返回参数列表){
	函数体
}
```

1. 在定义时调用匿名函数

   ```go
   func(num int){
   	fmt.println("num")
   }(100)//表示对匿名函数进行调用,传递形参100
   ```

2. 将匿名函数赋值给变量

   ```
   //将匿名函数体保存到a()中
   a:=func(num int){
   	fmt.println("num")
   }
   //使用a()调用
   a(100)
   ```

   匿名函数本身也是一个值,可以保存在各个容器中实现回调函数和操作封装

###### 使用匿名函数作为回调函数

###### 使用匿名函数实现操作封装



##### go语言函数类型实现接口-把函数作为接口来调用

函数和其他类型一样都属于“一等公民”，其他类型能够实现接口，函数也可以

1. 结构体实现接口

2. 函数体实现接口

3. HTTP包中的例子

   ```go
   //HTTP 包中包含有 Handler 接口定义，代码如下：
   type Handler interface {
       ServeHTTP(ResponseWriter, *Request)
   }
   //Handler 用于定义每个 HTTP 的请求和响应的处理过程。
   
   //同时，也可以使用处理函数实现接口，定义如下：
   type HandlerFunc func(ResponseWriter, *Request)
   func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
       f(w, r)
   }
   //要使用闭包实现默认的 HTTP 请求处理，可以使用 http.HandleFunc() 函数，函数定义如下：
   func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
       DefaultServeMux.HandleFunc(pattern, handler)
   }
   //而 DefaultServeMux 是 ServeMux 结构，拥有 HandleFunc() 方法，定义如下：
   func (mux *ServeMux) HandleFunc(pattern string, handler func
   (ResponseWriter, *Request)) {
       mux.Handle(pattern, HandlerFunc(handler))
   }
   //上面代码将外部传入的函数 handler() 转为 HandlerFunc 类型，HandlerFunc 类型实现了 Handler 的 ServeHTTP 方法，底层可以同时使用各种类型来实现 Handler 接口进行处理。
   ```

   

##### go语言闭包（Closure）

###### 闭包的理解

1. 一个外层函数中，有内层函数，该内层函数中，会操作外层函数中的局部变量(外层函数中的参数，
   或者外层函数直接定义的变量)，并且该外层函数的返回值就是这个内层函数。该内层函数和外层函数的局部变量，统称为闭包结构。局部变量的生命周期会发生改变，正常的局部变量随着函数的调用而创建，随着函数的结束而销毁。但是闭包结构中的外层函数的局部变量并不会随着外层函数的结束而销毁，因为内层函数还要继续使用。
2. 一个函数类型就像结构体一样，可以被实例化，函数本身不存储任何信息，只有与引用环境结合后形成的闭包才具有“记忆性”，函数是编译期静态的概念，而闭包是运行期动态的概念。

##### go语言可变参数

###### 可变参数类型

1. Go函数支持变参。接受变参的函数是有着不定数量的参数的

   ```go
   func f(arg ...int){}
   func f(args ...int) {
       for _, arg := range args {
           fmt.Println(arg)
       }
   }
   f(1,2,3,4)
   f(1,2,3)
   ```

2. args ...type 必须是最后一个参数,内部实现机理上来说，类型...type本质上是一个数组切片，也就是[]type，这也是为什么上面的参数 args 可以用 for 循环来获得每个传入的参数。

###### 任意类型的可变参数

1. args ...interface{}

##### go语言中函数的参数传递

###### go语言函数的参数也是存在值传递和引用传递的

1. 值传递
2. 引用传递

##### go中defer

###### 什么是defer

延迟（defer）语句，延迟语句被用于执行一个函数调用，在这个函数之前，延迟语句返回。

###### 延迟函数

1. 可以在函数中添加多个defer语句。当函数执行到最后时，这些defer语句会按照逆序执行，最后该函数返回。特别是当你在进行一些打开资源的操作时，遇到错误需要提前返回，在返回前你需要关闭相应的资源，不然很容易造成资源泄露等问题
2. 如果有很多调用defer，那么defer是采用后进先出模式
3. 在离开所在的方法时，执行（报错的时候也会执行）
4. 延迟函数的参数在执行延迟语句时被执行，而不是在执行实际的函数调用时执行

```
注意点：
当外围函数中的语句正常执行完毕时，只有其中所有的延迟函数都执行完毕，外围函数才会真正的结束执行。
当执行外围函数中的return语句时，只有其中所有的延迟函数都执行完毕后，外围函数才会真正返回。
当外围函数中的代码引发运行恐慌时，只有其中所有的延迟函数都执行完毕后，该运行时恐慌才会真正被扩展至调用函数。
```

##### go语言递归函数

1. 自己调用自己
2. 一定要有终止条件，否则就会无限调用下去，直到内存溢出

##### go语言计算函数执行时间

```go
func Since(t Time) Duration
```

##### 哈希函数

1. mad5
2. sha1

