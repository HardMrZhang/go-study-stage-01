# Map

------

1. map是什么

   -  map 是一种特殊的数据结构,一种元素对的无序集合,pair 对应一key和一个value,所以这个结构也称为关联数组或字典，这是一种能够快速寻找值的理想结构,给定 key,就可以迅速找到对应的 value。
   - map不能使用==操作符进行比较。==只能用来检查map是否为空

2. map声明

   - map属于引用类型

       ```golang
       var map_name map[key_type]value_type
       ```

   - 声明map是不需要知道map长度的,map的长度是可以动态增加的,
   - 没有初始化的map为nil
   - len()可以获得map的长度
   - 使用 `make()`，但不能使用 new() 来构造 map，如果错误的使用 new() 分配了一个引用对象，会获得一个空引用的指针，`相当于声明了一个未初始化的变量并且取了它的地址`

3. map容量

   - map的容量是根据新增或者删除动态伸缩的,因此它不存在固定长度或者最大限制,但是也可以选择标明 map 的初始容量capacity，比如 m3 := make(map[string]float32, 100)
   - 当 map 增长到容量上限的时候，如果再增加新的 key-value，map的大小会自动加 1，所以出于性能的考虑，对于大的 map 或者会快速扩张的 map,尽量指定大小

4. 遍历map

   - for range
   - 遍历输出元素的顺序与填充顺序无关，不能期望 map 在遍历时返回某种期望顺序的结果。

5. map元素的删除和清空

   - delete(map, 键)
   - Go语言中并没有为 map 提供任何清空所有元素的函数、方法，清空 map 的唯一办法就是重新 make 一个新的 map，不用担心垃圾回收的效率，Go语言中的并行垃圾回收效率比写一个清空函数要高效的多。

6. map的多件索引

7. sync.Map

   - map在并发情况下,只读是线程安全的,同时读写是线程不安全的
   - sync.Map 没有提供获取 map 数量的方法，替代方法是在获取 sync.Map 时遍历自行计算数量，sync.Map 为了保证并发安全有一些性能损失，因此在非并发情况下，使用 map 相比使用 sync.Map 会有更好的性能。

8. map的底层实现原理

   - 底层存储方式为数组，在存储时key不能重复，当key重复时，value进行覆盖，我们通过key进行hash运算（可以简单理解为把key转化为一个整形数字）然后对数组的长度取余，得到key存储在数组的哪个下标位置，最后将key和value组装为一个结构体，放入数组下标处

     ```golang
     length = len(arr) = 4
     hashkey1 = hash(a) = 4
     index1  = hashkey1% length= 0
     hashkey2 = hash(b) = 6
     index2  = hashkey2% length= 2
     ```

   - 开放定址法:

     ```
     当我们存储一个key，value时，发现hashkey(key)的下标已经被别key占用，那我们在这个数组中空间中重新找一个没被占用的存储这个冲突的key
     ```

     - 有线性探测法，线性补偿探测法，随机探测法

       ```
       有线性探测法:按照顺序来，从冲突的下标处开始往后探测，到达数组末尾时，从数组开始处探测，直到找到一个空位置存储这个key，当数组都找不到的情况下回扩容（事实上当数组容量快满的时候就会扩容了）；查找某一个key的时候，找到key对应的下标，比较key是否相等，如果相等直接取出来，否则按照顺寻探测直到碰到一个空位置，说明key不存在。
       ```

       

   - 拉链法

     ```
     简单理解为链表，当key的hash冲突时，我们在冲突位置的元素上形成一个链表，通过指针互连接，当查找时，发现key冲突，顺着链表一直往下找，直到链表的尾节点，找不到则返回空
     ```

   - 开放定址（线性探测）和拉链的优缺点

     - 由上面可以看出拉链法比线性探测处理简单
     - 线性探测查找是会被拉链法会更消耗时间
     - 线性探测会更加容易导致扩容，而拉链不会
     - 拉链存储了指针，所以空间上会比线性探测占用多一点
     - 拉链是动态申请存储空间的，所以更适合链长不确定的



------

# list

1. list是什么

   - 一种非连续的存储容器，由多个节点组成，节点通过一些变量记录彼此之间的关系，列表有多种实现方法，如单链表、双链表等。
   - Go语言中，列表使用 container/list 包来实现，内部的实现原理是双链表，列表能够高效地进行任意位置的元素插入和删除操作。

2. 声明一个list

   - 通过 container/list 包的 New() 函数初始化 list

     ```
     variable:=list.New()
     ```

   - 通过 var 关键字声明初始化 list

     ```
     var variable list.List
     ```

   - 列表与切片和 map 不同的是，列表并没有具体元素类型的限制，因此，列表的元素可以是任意类型，但是如果给列表中放入了一个 interface{} 类型的值，取出值后，如果要将 interface{} 转换为其他类型将会发生宕机

3. 向list中插入元素

   - 双链表支持从队列前方或后方插入元素，分别对应的方法是 PushFront 和 PushBack。
   - 往中间检插入,InsertAfter,InsertBefor

4. 从list删除元素

5. 遍历list